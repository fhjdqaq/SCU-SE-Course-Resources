## Chapter 1 Computer System Overview

软件分为两种类型：

①：系统软件  OS 硬盘碎片整理

②：应用软件 

**OS（连接软件和硬件之间的桥梁）（连接应用和硬件的接口）**

承上：Provides a set of services to system users

启下：Exploits the hardware resources 



处理器寄存器：CPU**内部的寄存器**



用户可见寄存器User-Visible Registers（AC寄存器（累加器））

**应用程序（用户态程序）可以直接访问和使用的寄存器**



控制状态寄存器Control and Status Registers（PC IR PSW 中断向量寄存器）

**仅由操作系统（内核态）或硬件控制的寄存器**，用于**管理处理器的工作状态、配置硬件功能、记录系统级信息**

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012133938842.png" alt="image-20251012133938842" style="zoom:33%;" />

**Instruction Cycle（指令周期）**

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012134135146.png" alt="image-20251012134135146" style="zoom:33%;" />

 **Why Interrupt in computer system?**中断也是这里面的重点知识

• Most I/O devices are slower than the processor， so interrupt can improve CPU’s utilization（提高 CPU利用率） 

• Processor must pause to wait for device 

• E.g.: printer  disk– Count （计数） – Avoid some program to monopolize CPU (避免CPU被 独占)

**中断的定义**

中断（Interrupt）是指**CPU 在执行程序过程中，遇到来自硬件或软件的紧急事件，暂停当前程序的执行，转而去处理该紧急事件，处理完毕后再返回原来程序中断处继续执行的过程**。

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012135103607.png" alt="image-20251012135103607" style="zoom:33%;" />



大概流程是：

硬件：

1. 检测是否存在中断
2. 如果存在中断的话将当前指令的PS和PSW寄存器内容保存
3. 将pc当中的值改写为中断服务程序的地址（**ISR**）（然后开始执行中断程序）

软件：

1. 保存剩余信息
2. 处理中断程序
3. 中断程序处理结束之后重新加载状态信息
4. 加载旧的PSW和PC

多个中断发生时：看系统是否允许多中断

如果可以的话就根据优先级来判断先执行哪一个中断

不行的就只能忽略了



**Multiprogramming 多道程序程序设计**

使用时间片+中断 using time slice which is enabled by timer  interrupt

给每个程序都分配一定时间营造一种都在执行的假象



 **Memory Hierarchy**

为什么这一种技术可以存在呢?

原因在于局部性原理

 Spatial locality (**空间**局部性)

Temporal locality (**时间**局部性)





 SMP（Symmetric Multiprocessors）– 对称多核处理

SMP 架构由**多个完全相同的处理器（CPU 核心）** 组成，这些处理器共享同一套系统资源（包括内存、I/O 设备、总线等），且由操作系统统一调度 ——**没有 “主处理器” 和 “从处理器” 的区别**，任何一个处理器都能执行任意任务（如进程调度、中断处理、I/O 操作），因此称为 “对称”。提高并行处理的能力。



| 技术类型                                     | 核心原理                                                     | 适用场景                                                     |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 程序查询（Programmed I/O, PIO）           | CPU 主动、循环查询 I/O 设备状态： 1. CPU 询问设备 “是否准备好”； 2. 设备未准备好 → CPU 继续等待（忙等）； 3. 设备准备好 → CPU 直接读写数据。 | 早期简单设备（如早期打印机），现代几乎不使用（CPU 利用率极低）。 |
| 2. 中断驱动（Interrupt-Driven I/O）          | CPU 无需等待，由设备主动 “通知” CPU： 1. CPU 向设备发送指令后，继续执行其他任务； 2. 设备准备好数据 → 向 CPU 发送中断请求； 3. CPU 暂停当前任务，处理中断（读写数据），完成后返回原任务。 | 中低速设备（如键盘、鼠标、打印机），是现代系统的基础 I/O 技术。 |
| 3. 直接内存访问（DMA, Direct Memory Access） | 由 **DMA 控制器（硬件）** 代替 CPU 完成数据传输： 1. CPU 向 DMA 控制器指定 “数据源、目标地址、传输长度”； 2. DMA 直接在设备与内存间传输数据（无需 CPU 参与）； 3. 传输完成 → DMA 向 CPU 发中断，CPU 仅处理 “传输完成” 事件。 | 高速设备（如磁盘、网卡、显卡），是现代系统高性能 I/O 的核心。 |
| 4. 通道（Channel I/O）                       | 由 **I/O 通道（专用处理器）** 管理多个设备的传输： 1. CPU 向通道发送 “通道程序”（包含多个 I/O 任务）； 2. 通道独立执行程序，控制多个设备并行传输数据； 3. 所有任务完成 → 通道向 CPU 发中断。 | 大型机、服务器（需连接大量高速设备，如多块磁盘组成的存储阵列）。 |





 Operating System Objectives 

As Resource Manager--Efficiency /有效   管理对CPU的控制

As User/Computer Interface --Convenience/方便

As System Software--Ability to evolve /扩展

**内核是操作系统的 “核心引擎”，负责管理硬件资源；进程管理 调度**

**外壳是操作系统的 “用户接口”，负责接收和解析用户指令**。



**串行处理**：存在两个问题

**调度** Most installations used a hardcopy sign-up sheet  to reserve computer time

**准备时间** included loading the compiler, source program,  saving compiled program, and loading and linkin



**简单批处理**：

将这个批作业放到磁盘上，监控程序监控到上一个执行完了就去执行下一个<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012142522761.png" alt="image-20251012142522761" style="zoom:33%;" />

**多道批处理系统**（现代操作系统主要的方案）

1. 单道程序设计：遇到I/O指令需要等到I/O指令结束以后才可以继续进行
2. 多道程序设计：在一个作业等到I/O的时候，可以去执行另一个不需要I/O的作业

⽆交互，靠作业控制命令

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012143146831.png" alt="image-20251012143146831" style="zoom:33%;" />

**分时系统：**

有交互，靠用户输⼊命令

![image-20251012143220776](C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012143220776.png)



操作系统开发中4个重要的理论进展

进程，信息保护和安全，内存管理，调度与资源管理

![image-20251012145510308](C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012145510308.png)







**进程的定义**（两个基本元素：程序代码和代码相关的数据集

 Definition: 

1.  A program in execution

2. An instance of a program running on a computer 
3. The entity that can be assigned to and executed on  a processor
4.    A unit of activity characterized by： 
5. the execution of a sequence of  instructions a current state an associated set of system resources

我们可以使用一个进程控制块（PCB）来表征一个进程

每个进程在操作系统中都有一个唯一对应的进程控制块（Process Control Block, PCB）

进程控制块包含了操作系统所需进程的所有信息，操作系统当中的每一个模块都可以读取和修改他们

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012150404035.png" alt="image-20251012150404035" style="zoom:25%;" />

**进程模型**：这是重点当中的重点

两状态模型：仅包含一个运行态和一个非运行态

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012153433960.png" alt="image-20251012153433960" style="zoom:33%;" />

缺点：不能简单的选择队列中排队时间最长的因为万一排队最长的这个进程处于阻塞态，将CPU资源分配给它也用不了，太浪费了。

所以要区分进程状态：将非运行态分为就绪态和阻塞态

五状态模型：

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012154313998.png" alt="image-20251012154313998" style="zoom:33%;" />

构建了两种阻塞队列但是第一种需要扫描整个阻塞队列，收缩到等待时间发生的队列

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012154555194.png" alt="image-20251012154555194" style="zoom:33%;" />

五状态模型也存在弊端，队列当中所有的进程都必须完全载入内存当中

1. 想要容纳更多的进程就必须要使用更大的内存
2. 或者交换将某一个进程一部分或者全部移动到磁盘当中

所以我们增加了一个挂起态，现在变为了6状态

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012160030920.png" alt="image-20251012160030920" style="zoom:33%;" />



但是需要注意的一个点是，如果所有被挂起的状态都处于阻塞态的时候，将阻塞态的进程取回内存没有任何意义，因为因为它还没有做好被执行的准备。

所以优化为七状态

挂起态和非挂起态的区别在于再内存当中还是再外存当中

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012160425908.png" alt="image-20251012160425908" style="zoom:33%;" />

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012160524388.png" alt="image-20251012160524388" style="zoom:33%;" />

<img src="C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012161122078.png" alt="image-20251012161122078" style="zoom:33%;" />

**进程映像**：

![image-20251012161823476](C:\Users\13235\AppData\Roaming\Typora\typora-user-images\image-20251012161823476.png)

再内存当中分布可以不连续，虚拟内存的知识需要看一下

<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251013113549017.png" alt="image-20251013113549017" style="zoom:50%;" />

处理器状态信息：用户可见寄存器  控制状态寄存器  栈指针

进程控制信息：Process Privileges进程特权等

用户栈存放的信息是局部变量，函数参数，返回地址                         

私有用户地址空间存放程序代码和创新运行时的数据     内核栈



**进程控制**：

处理器支持两种执行模式：（操作系统为了实现**权限隔离**和**系统安全**而设计的两种处理器执行状态，它们的核心区别在于对硬件资源的访问权限和可执行的指令范围。）

1. User mode

用户程序执行时

1. System mode,control mode,kernel mode

操作系统内核典型功能（大概是下面这些操作）也就是下面这些功能都运行在操作系统的内核模式之下

<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012190743654.png" alt="image-20251012190743654" style="zoom: 33%;" /><img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012190827556.png" alt="image-20251012190827556" style="zoom: 45%;" />

**进程创建**

| 步骤序号 | 具体操作                    | 说明                                                         |
| -------- | --------------------------- | ------------------------------------------------------------ |
| 1        | 分配唯一的进程标识符（PID） | 为新进程分配一个系统内唯一的标识符，用于标识和管理该进程     |
| 2        | 为进程分配空间              | 为进程分配所需的内存空间，包括代码段、数据段、堆、栈等       |
| 3        | 初始化进程控制块（PCB）     | 填写进程控制块中的信息，如进程 ID、状态、优先级、程序计数器、寄存器值、内存分配信息等 |
| 4        | 建立适当的链接关系          | 例如，将新进程添加到用于调度队列的链表中，使其能被调度器选中执行 |
| 5        | 创建或扩展其他数据结构      | 例如，维护一个记账文件，用于记录进程的资源使用情况等信息     |

进程创建的触发场景包括：

用户启动新应用程序（user）

操作系统为特定任务（如打印）创建进程（os）

现有进程创建子进程（如 VSCode 运行 h.exe）（exiting process）

**进程切换**

| 事件类型                                  | 具体说明                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| 时钟中断（Clock interrupt）               | 进程已执行完系统允许的最大时间片，触发时钟中断使操作系统获得控制权 |
| I/O 中断                                  | 输入 / 输出操作完成或出现异常时产生的中断，操作系统需处理相应 I/O 请求 |
| 内存故障（Memory fault）                  | 引用的虚拟地址不在主内存中，需要将其调入内存时触发，操作系统介入处理内存映射 |
| 陷阱（Trap）                              | 发生错误或异常（如除零错误、非法指令等），可能导致进程进入退出状态，操作系统负责处理异常 |
| 系统调用（Supervisor call / System Call） | 进程请求操作系统提供服务（如文件操作、进程创建等），操作系统接管控制权以执行相应服务 |

**进程切换**

| 步骤序号 | 操作内容                                          | 说明                                                         |
| -------- | ------------------------------------------------- | ------------------------------------------------------------ |
| 1        | 保存处理器上下文，包括程序计数器和其他寄存器      | 记录当前运行进程的所有硬件状态（如指令地址、数据寄存器值等），为后续恢复做准备 |
| 2        | 更新当前运行进程的进程控制块（PCB），并修改其状态 | 将当前进程的状态从 “运行（Running）” 更改为合适的新状态（如就绪、阻塞等），同时更新 PCB 中的相关信息 |
| 3        | 将进程控制块移至相应的队列                        | 根据步骤 2 修改后的状态，将当前进程的 PCB 加入对应的队列（如就绪队列、阻塞队列、就绪挂起队列等） |
| 4        | 选择另一个进程执行（调度）                        | 由进程调度器根据调度算法从就绪队列中选择下一个要运行的进程   |
| 5        | 更新被选中进程的进程控制块（PCB），并修改其状态   | 将被选中进程的状态从 “就绪（Ready）” 更改为 “运行（Running）”，同时更新其 PCB 中的相关信息 |
| 6        | **更新内存管理数据结构**                          | 调整内存映射等数据结构，确保新进程能正确访问其内存空间（如加载页表、映射虚拟地址等） |
| 7        | 恢复被选中进程的上下文                            | 将被选中进程之前保存的寄存器值等上下文信息加载到处理器中，使其开始执行 |



第六步再中断切换当中不会涉及，因为进程切换是从一个进程改变为了另一个进程，代码数据需要更新，而中断操作只是暂时切换，暂缓当前进程进行I/O操作去了。



**进程终止**

<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012195357208.png" alt="image-20251012195357208" style="zoom:67%;" />



![image-20251012203024146](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012203024146.png)

- 图（a）是**传统宏内核**思路：内核集中式提供所有服务，与用户进程严格隔离。
- 图（b）是**混合架构**：系统服务分散到用户进程内，减少模式切换开销。
- 图（c）是**微内核**思路：系统服务拆分为独立进程，通过进程间通信协作，强调模块化和可靠性。

先看a，分离的内核（无进程内核）：进程这一概念仅适用于用户程序，而操作系统代码则是在特权模式下单独运行的实体。

再看b，在用户进程的上下文当中执行所有操作系统软件，此时操作系统是用户调用的一组例程，它在用户进程的环境当中执行实现各种功能。<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012185728879.png" alt="image-20251012185728879" style="zoom:33%;" />现在的进程映像是这样的，**内核栈**是为内核程序服务的，主要存放内核函数调用时的局部变量、函数参数、返回地址以及内核程序在执行过程中保存的寄存器值等，操作系统的代码和数据放在共享地址空间当中。**共享地址空间**中的内核代码和数据，是**所有进程都能 “看到” 并调用**的公共资源（但调用时的上下文由每个进程的内核栈单独维护）。

涉及内核模式（内核态）时在用户进程中执行的代码是通向操作系统的代码并非用户代码。但是根据用户模式和内核模式，即使操作系统例程在用户进程环境当中执行的时候，用户也不能篡改。

最后看c，将操作系统作为一组系统进程来实现 Useful in multi-processor or multi-computer environment



![image-20251012195539211](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012195539211.png)

**使用fork时**

在父进程当中，fork返回新创建子进程的进程ID

在子进程当中，fork返回0

出现错误的话会返回0

**一定要注意子进程保存的时父进程的一个副本信息，子进程修改了，父进程当中也不会改变**

子进程只执行fork以及之后的代码，前面的代码不重复执行

• wait: 父进程等待子进程终止并返回 

• why：进程只能释放自己的空间，不能销毁自己 的PCB，父进程销毁子进程的PCB

• 孤儿进程：父进程已经结束，子进程尚未结束

<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012200922807.png" alt="image-20251012200922807" style="zoom:67%;" />

**这里具体的代码可以看实验**



下面通过表格清晰对比两者在这两个维度的差异，以及其他关键区别：

| 对比维度                                | 进程（Process）                                              | 线程（Thread）                                               | 核心结论                                                     |
| --------------------------------------- | ------------------------------------------------------------ | :----------------------------------------------------------- | ------------------------------------------------------------ |
| **资源所有权（Resource Ownership）**    | 1. **独立虚拟地址空间**：每个进程有专属的代码段、数据段、堆、栈，进程间地址空间完全隔离（需通过 IPC 共享数据）； 2. **独立资源集合**：拥有独立的 I/O 句柄（如打开的文件、网络连接）、信号处理上下文、进程 ID（PID）等； 3. **资源开销高**：创建 / 销毁时需分配 / 释放整个地址空间和资源集合。 | 1. **共享进程地址空间**：线程无独立地址空间，与同一进程内的其他线程共享代码段、数据段、堆（仅线程栈是独立的，用于存储自身局部变量和函数调用信息）； 2. **共享进程资源**：共享进程的 I/O 句柄、信号处理策略、PID 等（仅线程 ID（TID）、线程栈、寄存器上下文是独立的）； 3. **资源开销低**：创建 / 销毁仅需分配独立的线程栈和寄存器上下文，无需操作地址空间。 | 进程是 “**资源分配的基本单位**”，线程是 “**资源共享的执行单元**”—— 线程依赖进程的资源才能运行，同一进程内的线程通过共享地址空间实现高效数据交互。 |
| **调度 / 执行（Scheduling/Execution）** | 1. **调度单位粒度粗**：进程是早期 OS 的基本调度单位，调度时需切换整个地址空间（内存映射、TLB 刷新等），切换开销高； 2. **执行路径独立但隔离**：每个进程有独立的执行路径，但进程间执行流的切换需内核介入，且因地址空间隔离，无法直接共享执行状态。 | 1. **调度单位粒度细**：线程是现代 OS 的基本调度单位，调度时无需切换地址空间（共享进程内存映射），仅需切换线程栈和寄存器上下文，切换开销远低于进程； 2. **执行路径独立且共享**：每个线程有独立的程序计数器（PC）、寄存器上下文，执行路径可与同一进程内的其他线程 “interleaved（交错执行）”，且通过共享地址空间可直接访问进程数据（需同步机制避免冲突）。 | 线程是 “**调度与执行的基本单位**”——OS 通过调度线程实现 CPU 时间的精细分配，同一进程内的多线程可 “并发执行”，且切换效率远高于多进程。 |
| **其他关键区别**                        | - 进程间通信（IPC）复杂：需通过管道、共享内存、消息队列等内核提供的机制，且数据传递需拷贝（或映射）； - 故障隔离性强：一个进程崩溃（如内存错误）不会影响其他进程（地址空间隔离）。 | - 线程间通信简单：可直接读写同一进程内的共享变量（需加锁、信号量等同步机制，避免竞态条件）； - 故障隔离性弱：一个线程崩溃（如栈溢出）可能导致整个进程崩溃（共享地址空间，错误可能污染进程数据）。 | 进程适合 “独立任务、故障隔离” 场景（如浏览器的每个标签页作为独立进程）；线程适合 “同一任务内的并行执行” 场景（如文件下载器的多线程下载）。 |

**一个进程包含至少一个线程（称为 “主线程”），进程提供线程运行所需的资源（地址空间、I/O 等），线程提供进程内的独立执行路径（调度单位）** 

![image-20251012201649142](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012201649142.png)

**Thread**：

有自己独立的pc，**每个线程能单独记录自己的 “执行进度”**

pre-thread stack也有自己的**线程栈**：保存局部数据仅该线程可见

<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012202653429.png" alt="image-20251012202653429" style="zoom:67%;" />

user address space当中需要存放的是全局变量，如果将变量当成局部变量会出现像实验四一样的错误情况发生。

Heap 所有线程共享

堆是**进程级的资源**，由操作系统在进程初始化时分配一块 “初始堆空间”

**堆：**　是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。



**栈：**是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。

![image-20251012204513077](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012204513077.png)

记住了Running ， ready 是调度决定的，派生，阻塞等是操作决定的

然后针对线程我们不讨论挂起，因为挂起是针对进程的，线程共享用户空间

•Suspending a process involves suspending all threads of the process

–swap address space to disk

**阻塞一个线程并不会阻塞整个进程**



![image-20251012205104189](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251012205104189.png)

User-Level Thread

1. 所有线程管路都由应用程序完成
2. 内核不知道线程的存在

优点：

1. 从一个线程到另一个线程不需要内核态
2. 调度应用可以不同，有进程自己去决定
3. 无需修改底层内核修改

缺点：（jacketing加一层判断这个线程是否会阻塞，通过等待来解决）

1. 因为内核看不到线程，那么一个线程阻塞整个进程都会被阻塞
2. 并发度优势体现不出来
3. 线程不能分配到多核

Kernel-Level Thread

1. 线程管理交给内核
2. 内核为进程和线程维护上下文信息
3. 调度是以线程为单位进行的

优点：

1. 多CPU执行
2. 仅阻塞单个线程

缺点：

1. 切换时间上来了，相对单词的进程切换来说还是要快一些
2. 内核地址空间可能无法找到那么多线程控制块



<img src="C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251023083900962.png" alt="image-20251023083900962" style="zoom:33%;" />



**取址执行查终端**

![image-20251016084321296](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251016084321296.png)

在**process1**当中为什么**Reg1**为什么还是100->101？因为在查中断的时候会发生保护上下文的操作，此时在**process1**当中的**Reg1**存放的是一个副本已经放在栈当中了。多核当中，**Reg1**也是不同核当中的寄存器。



**需要学会如何判断输出结果是如何切换进程来实现的**



•**为啥代码先create线程p1,后创建p2，但先执行的是p2？**

•1.线程创建后会进入就绪态等待执行

•2.可能存在多核，不能肯定那个线程先执行



•**为啥p2全部执行完了才是p1**

•主要看p2的全部执行是否会用完一次时间片，另外当有更高优先级线程来时，也会发生抢占



![image-20251021171032697](C:/Users/13235/AppData/Roaming/Typora/typora-user-images/image-20251021171032697.png)**a=3,b=3**

**a=3,b=2**

得到这种输出的原因是什么呢？

ans：先跑P2，将b压入堆栈后，切换到P1当中执行2+1=3，所以输出项第一条的语句

此时a=3，b=3，但是在P2中只有a没有压入堆栈了，所以输出第二条语句



问题：

**进程间的资源争用**

**线程切换不确定**，**导致需要连续执行的几条指令被分开执行**



解决方法：

Mutual Exclusion(互斥)

•Critical sections(临界区)

–Only one program at a time is allowed in its critical section 某时只允许一个程序访问临界区

»E.g. only one process at a time is allowed to send command to the printer

–Resources in critical sections are accessed exclusively资源在临界区被互斥访问

•核心思想就是把争抢的资源（变量）放入**临界区**，当一个线程访问该资源未结束时（即进入临界区执行代码，且尚未执行到临界区外），不允许其它线程对该资源进行访问，从而在临界区实现对**资源访问的互斥**。


